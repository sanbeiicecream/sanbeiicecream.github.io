[{"content":"结论：ECharts版本太高可能导致这个报错\n源码地址\n1 2 3 4 5 6 import ReactEcharts from \u0026#39;echarts-for-react\u0026#39; \u0026lt;ReactEcharts option={} style={{ height: \u0026#39;350px\u0026#39;, width: \u0026#39;100%\u0026#39; }} /\u0026gt; 依赖\n1 2 3 4 \u0026#34;dependencies\u0026#34;: { ... \u0026#34;size-sensor\u0026#34;: \u0026#34;^1.0.0\u0026#34; // DOM 元素尺寸监听器，当元素尺寸变化的时候，将会触发回调函数！ }, 查看函数调用栈\n调试代码 resizeObserver.js\n在使用ResizeObserver 对象的dsconnect方法时提示的错误\n可以看见在执行这里时sensor等于undefined，意思是执行到destroy的时候还没有执行bind，所以导致的错误，继续往上层找\nsensorPool里面调用的destroy，但是没有看到bind，继续往上层找\n在上一层的index文件里面找到导出bind的地方，看是哪里引用的，继续往外层找\n在core.js文件里面看见导入的index\n分析 可以知道在EchartsReact组件卸载的时候会调用dispose，这时会判断有没有echartsElement，有的话就调用clear方法\n这个echartsElement是从哪里来的呢？\n1 2 3 4 5 6 7 8 9 10 11 _this.dispose = function () { if (_this.echartsElement) { try { (0, _sizeSensor.clear)(_this.echartsElement); } catch (e) { console.warn(e); } // dispose echarts instance _this.echartsLib.dispose(_this.echartsElement); } }; 在组件render的时候产生的\n这里去查看源码 知道了echartsLib是echarts导出\n1 2 3 4 5 6 7 8 9 10 11 // src/index.js import echarts from \u0026#39;echarts\u0026#39;; import EchartsReactCore from \u0026#39;./core\u0026#39;; // export the Component the echarts Object. export default class EchartsReact extends EchartsReactCore { constructor(props) { super(props); this.echartsLib = echarts; } } 经过调试发现下面这行执行完后触发了componentWillUnmount\n然后执行了dispose()，相当于还没渲染完成就卸载了\n为什么还没渲染完成就卸载组件了？这就是导致报错的原因\n既然是在echats获取实例的时候报错了，这很大程度可能是因为echats内部导致的报错\n查看echarts-for-react的packge.json包\n发现echarts-for-react 2.x版本只支持到4.x版本\n但是在本地项目中安装了5.x版本\n版本冲突导致的问题！\n在npm install的时候也提示了\n总结 发现项目内部依赖报错时，需要先检查一下依赖包依赖的外部包版本（peerDependencies）是否安装正确\n如果有sourcemap可以很好看见打包没有压缩的代码，直接在浏览器上进行断点调试更为方便\n","permalink":"https://sanbeiicecream.github.io/posts/%E4%BD%BF%E7%94%A8echarts-for-react%E6%8A%A5%E9%94%99cannot-read-properties-of-undefined-reading-disconnect/","summary":"结论：ECharts版本太高可能导致这个报错 源码地址 1 2 3 4 5 6 import ReactEcharts from \u0026#39;echarts-for-react\u0026#39; \u0026lt;ReactEcharts option={} style={{ height: \u0026#39;350px\u0026#39;, width: \u0026#39;100%\u0026#39; }} /\u0026gt; 依赖 1 2 3 4 \u0026#34;dependencies\u0026#34;: { ... \u0026#34;size-sensor\u0026#34;: \u0026#34;^1.0.0\u0026#34; // DOM 元素尺寸监听器，当元素尺","title":"使用echarts-for-react报错：Cannot read properties of undefined (reading 'disconnect')"},{"content":"mdn 使用WebApi功能实现\n好处：这个拖拽是浏览器级别的功能，可以与其他应用交互\n小缺陷：样式不能很好自定义，比如拖拽到放置区的鼠标的图标只有4种样式\ncopy：在新位置生成源项的副本 move：将项目移动到新位置 link：在新位置建立源项目的链接 none： 项目可能禁止拖放（默认） 确定什么是可拖拽的 让一个元素被拖拽需要添加 draggable 属性\n1 \u0026lt;p id=\u0026#34;p1\u0026#34; draggable=\u0026#34;true\u0026#34;\u0026gt;This element is draggable.\u0026lt;/p\u0026gt; 怎么定义一个放置区 当拖拽一个项目到 HTML 元素中时，浏览器默认不会有任何响应。想要让一个元素变成可释放区域，该元素必须设置ondragover和ondrop事件处理程序属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script\u0026gt; function dragover_handler(ev) { ev.preventDefault(); ev.dataTransfer.dropEffect = \u0026#34;move\u0026#34;; } function drop_handler(ev) { ev.preventDefault(); // Get the id of the target and add the moved element to the target\u0026#39;s DOM var data = ev.dataTransfer.getData(\u0026#34;text/plain\u0026#34;); ev.target.appendChild(document.getElementById(data)); } \u0026lt;/script\u0026gt; \u0026lt;p id=\u0026#34;target\u0026#34; ondrop=\u0026#34;drop_handler(event)\u0026#34; ondragover=\u0026#34;dragover_handler(event)\u0026#34;\u0026gt; Drop Zone \u0026lt;/p\u0026gt; 数据交互 拖拽与释放的数据交互在于drag事件上的dataTransfer对象\nDataTransfer 对象用于保存拖动并放下（drag and drop）过程中的数据。它可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型\n每个数据项都是一个 string 类型，典型的 MIME 类型，如：text/html\n（也可以是其他随机key，不是MIME的key，会影响到拖拽到其他程序显示的值，直接不显示）\n拖放到其他程序时，默认取的值是最后一个设置值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function dragstart_handler(ev) { // 添加拖拽数据 ev.dataTransfer.setData(\u0026#34;text/plain\u0026#34;, ev.target.innerText); ev.dataTransfer.setData(\u0026#34;text/html\u0026#34;, ev.target.outerHTML); ev.dataTransfer.setData( \u0026#34;text/uri-list\u0026#34;, ev.target.ownerDocument.location.href, ); } // 释放事件获取值 function drop_handler(ev) { const data = ev.dataTransfer.getData(\u0026#34;text/plain\u0026#34;); } 其他 定义拖拽图像\n控制台需要关闭才能显示\n1 2 3 4 5 6 7 8 function dragstart_handler(ev) { // Create an image and then use it for the drag image. // NOTE: change \u0026#34;example.gif\u0026#34; to a real image URL or the image // will not be created and the default drag image will be used. var img = new Image(); img.src = \u0026#34;example.gif\u0026#34;; ev.dataTransfer.setDragImage(img, 0, 0); } ","permalink":"https://sanbeiicecream.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%96%E6%8B%BD/","summary":"mdn 使用WebApi功能实现 好处：这个拖拽是浏览器级别的功能，可以与其他应用交互 小缺陷：样式不能很好自定义，比如拖拽到放置区的鼠标的图标只有4","title":"浏览器拖拽"},{"content":"官方推荐使用snap安装\nUnless you have very specific requirements, we kindly suggest that you use the installation instructions for your system found at https://certbot.eff.org/instructions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 查看系统版本 cat /etc/centos-release # 安装snapd yum install snapd # 安装后，需要启用管理snap通信套接字的systemd unit systemctl enable --now snapd.socket # 为了启用classic snap的支持，需要创建如下软连接 ln -s /var/lib/snapd/snap /snap # 重启后 snap install core snap refresh core # 安装certbot snap install --classic certbot ln -s /snap/bin/certbot /usr/bin/certbot # 验证方式 # https://letsencrypt.org/zh-cn/docs/challenge-types/ # 建议使用dns txt记录验证 # https://eff-certbot.readthedocs.io/en/stable/using.html#manual certbot --manual certonly --preferred-challenges=dns # 根据certbot提示，会让输入用户名与邮箱 # 然后输入需要解析的域名，certbot就会输出一个txt内容 # 此时需要把这个内容放到指定的txt解析域名下（一般是_acme-challenge） # 查看txt域名解析，解析值对上certbot输出的内容后，再下一步 dig TXT \u0026lt;yourdomain.com\u0026gt; # 查看证书 certbot certificates # 续订 certbot renew ","permalink":"https://sanbeiicecream.github.io/posts/%E4%BD%BF%E7%94%A8certbot%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6/","summary":"官方推荐使用snap安装 Unless you have very specific requirements, we kindly suggest that you use the installation instructions for your system found at https://certbot.eff.org/instructions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37","title":"使用certbot申请证书"},{"content":"ctrl+shift+f在各大IDE上都是用来做全局搜索的\n如果使用中文输入法，有个简繁转换也默认是这个快捷键，导致了快捷键冲突，很不方便，可以设置关闭这个快捷键\n解决 右击状态栏这个，然后在弹出的选项中选择设置\n有可能没有进入输入法设置页面（坑）\n只能进这里\n点击语言选项，进入下一个页面\n这里键盘如果没有添加的话就进不去键盘选项页面\n添加微软拼音后，就可以设置了\n现在右击上面的设置也能直接进入键盘选项了\n关闭或修改这个热键，解决冲突！ 总结 关键点在于win11的默认设置可能没有键盘的原因，导致键盘选项出不来\n","permalink":"https://sanbeiicecream.github.io/posts/%E8%A7%A3%E5%86%B3ctrl+shift+f%E8%A2%ABwin11%E8%BE%93%E5%85%A5%E6%B3%95%E5%8D%A0%E7%94%A8/","summary":"ctrl+shift+f在各大IDE上都是用来做全局搜索的 如果使用中文输入法，有个简繁转换也默认是这个快捷键，导致了快捷键冲突，很不方便，可","title":"解决ctrl+shift+f被win11输入法占用"},{"content":"在使用Egg作为服务端，上传jfif文件时报了个错\n1 ctx.getFileStream() 这次抱着深究源码的态度进行解决问题，进行查看相关关键代码\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // node_modules\\.pnpm\\egg-multipart@3.3.0\\node_modules\\egg-multipart\\app.js // 插件入口 \u0026#39;use strict\u0026#39;; const { normalizeOptions } = require(\u0026#39;./lib/utils\u0026#39;); module.exports = class AppBootHook { constructor(app) { this.app = app; } configWillLoad() { // 配置初始化 this.app.config.multipart = normalizeOptions(this.app.config.multipart); const options = this.app.config.multipart; this.app.coreLogger.info(\u0026#39;[egg-multipart] %s mode enable\u0026#39;, options.mode); if (options.mode === \u0026#39;file\u0026#39; || options.fileModeMatch) { this.app.coreLogger.info(\u0026#39;[egg-multipart] will save temporary files to %j, cleanup job cron: %j\u0026#39;, options.tmpdir, options.cleanSchedule.cron); // enable multipart middleware this.app.config.coreMiddleware.push(\u0026#39;multipart\u0026#39;); } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //node_modules\\.pnpm\\egg-multipart@3.3.0\\node_modules\\egg-multipart\\lib\\utils.js // 内置文件名白名单 exports.whitelist = [ // images \u0026#39;.jpg\u0026#39;, \u0026#39;.jpeg\u0026#39;, // image/jpeg \u0026#39;.png\u0026#39;, // image/png, image/x-png \u0026#39;.gif\u0026#39;, // image/gif \u0026#39;.bmp\u0026#39;, // image/bmp \u0026#39;.wbmp\u0026#39;, // image/vnd.wap.wbmp \u0026#39;.webp\u0026#39;, \u0026#39;.tif\u0026#39;, \u0026#39;.psd\u0026#39;, // text \u0026#39;.svg\u0026#39;, \u0026#39;.js\u0026#39;, \u0026#39;.jsx\u0026#39;, \u0026#39;.json\u0026#39;, \u0026#39;.css\u0026#39;, \u0026#39;.less\u0026#39;, \u0026#39;.html\u0026#39;, \u0026#39;.htm\u0026#39;, \u0026#39;.xml\u0026#39;, // tar \u0026#39;.zip\u0026#39;, \u0026#39;.gz\u0026#39;, \u0026#39;.tgz\u0026#39;, \u0026#39;.gzip\u0026#39;, // video \u0026#39;.mp3\u0026#39;, \u0026#39;.mp4\u0026#39;, \u0026#39;.avi\u0026#39;, ]; exports.normalizeOptions = options =\u0026gt; { //... // normalize whitelist if (Array.isArray(options.whitelist)) options.whitelist = options.whitelist.map(extname =\u0026gt; extname.toLowerCase()); // normalize fileExtensions if (Array.isArray(options.fileExtensions)) { options.fileExtensions = options.fileExtensions.map(extname =\u0026gt; { return (extname.startsWith(\u0026#39;.\u0026#39;) || extname === \u0026#39;\u0026#39;) ? extname.toLowerCase() : `.${extname.toLowerCase()}`; }); } //... function checkExt(fileName) { if (typeof options.whitelist === \u0026#39;function\u0026#39;) return options.whitelist(fileName); const extname = path.extname(fileName).toLowerCase(); if (Array.isArray(options.whitelist)) return options.whitelist.includes(extname); // 或条件，存在白名单中或者在extname配置中 return exports.whitelist.includes(extname) || options.fileExtensions.includes(extname); } options.checkFile = (fieldName, fileStream, fileName) =\u0026gt; { // just ignore, if no file if (!fileStream || !fileName) return null; try { // 文件名是否允许上传的判断，不可以就抛出异常 if (!checkExt(fileName)) { const err = new Error(\u0026#39;Invalid filename: \u0026#39; + fileName); err.status = 400; return err; } } catch (err) { err.status = 400; return err; } }; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // node_modules\\.pnpm\\egg-multipart@3.3.0\\node_modules\\egg-multipart\\app\\extend\\context.js const parse = require(\u0026#39;co-busboy\u0026#39;); //... module.exports = { // 创建multipart.parts实例 multipart(options) { //... const { autoFields, defaultCharset, defaultParamCharset, checkFile } = ctx.app.config.multipart; const { fieldNameSize, fieldSize, fields, fileSize, files } = ctx.app.config.multipart; options = extractOptions(options); const parseOptions = Object.assign({ autoFields, defCharset: defaultCharset, defParamCharset: defaultParamCharset, checkFile, }, options); // https://github.com/mscdex/busboy#busboy-methods // merge limits parseOptions.limits = Object.assign({ fieldNameSize, fieldSize, fields, fileSize, files, }, options.limits); const parts = parse(this, parseOptions); }, // egg中获取上传文件流的方法 async getFileStream(options = {}) { options.autoFields = true; // 调用上面函数 const parts = this.multipart(options); let stream = await parts(); //... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // node_modules\\.pnpm\\co-busboy@2.0.0\\node_modules\\co-busboy\\index.js // 用于解析传入的 HTML 表单数据 var Busboy = require(\u0026#39;busboy\u0026#39;) ... var busboy = Busboy(options) var checkFile = options.checkFile ... request = inflate(request) request.on(\u0026#39;close\u0026#39;, cleanup) busboy .on(\u0026#39;field\u0026#39;, onField) .on(\u0026#39;file\u0026#39;, onFile) .on(\u0026#39;close\u0026#39;, cleanup) .on(\u0026#39;error\u0026#39;, onEnd) .on(\u0026#39;finish\u0026#39;, onEnd) // 解析文件流类型 function onFile(fieldname, file, info) { var filename = info.filename var encoding = info.encoding var mimetype = info.mimeType if (checkFile) { // 关键，查看文件流是否符合条件 var err = checkFile(fieldname, file, filename, encoding, mimetype) if (err) { // make sure request stream\u0026#39;s data has been read var blackHoleStream = new BlackHoleStream() file.pipe(blackHoleStream) return onError(err) } } // opinionated, but 5 arguments is ridiculous file.fieldname = fieldname file.filename = filename file.transferEncoding = file.encoding = encoding file.mimeType = file.mime = mimetype ch(file) } busboy\n根据上面代码可以看出ctx.getFileStream()使用了内置的egg-multipart插件\n执行流程大概是先使用normalizeOptions进行egg的multipart配置初始化，后续在创建的multipart.parts实例中对流进行判断处理。其中使用checkFile对文件流判断，报错原因就是因为文件名称没有存在whitelist或extname配置中\n解决办法 1 2 3 4 5 6 7 // app\\config\\config.default.js module.exports = appInfo =\u0026gt; { config.multipart = { fileExtensions: [\u0026#39;jfif\u0026#39;], // 需要上传文件的后缀，如果存在whitelist中可以不添加 }; } 总结 观看源码可以直奔主题，看的是实现思路，而不需要把每行代码都看懂，这样可以加快源码阅读的速度。\n","permalink":"https://sanbeiicecream.github.io/posts/egg%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/","summary":"在使用Egg作为服务端，上传jfif文件时报了个错 1 ctx.getFileStream() 这次抱着深究源码的态度进行解决问题，进行查看相关关键代码 源码 1 2 3 4 5 6 7 8 9 10 11 12 13","title":"Egg中获取文件流的时候，抛出异常"},{"content":"https://docs.docker.com/network/\n1 2 # 查看docker网络 docker network ls 在创建容器时，使用-P -p 可以端口映射与宿主机进行通信；如果多个容器使用同一个主机端口创建容器会报错 容器之间可以直接通过ip地址通信，可以使用docker inspect 【name】| grep IPAddress 查看容器ip地址。这种方式不太好，需要先获取地址，才能设置docker启动命令；\n使用主机网络模式：在运行容器时，可以使用--network=host标志，将容器加入宿主机的网络命名空间。这样，容器将直接使用宿主机的网络接口，可以直接通过宿主机的IP地址进行通信。但请注意，这将使容器与宿主机共享网络栈，可能导致端口冲突和安全隐患。\n通过docker的桥接网络 bridge：相当于将多个容器添加进一个网络里面，使用内部的==dns==进行解析访问\n1 2 3 4 5 6 7 8 # 创建一个网络环境，名为networkName: docker network create networkName # 分别将两个容器添加到这个网络中 docker network connect networkName 【容器名】 docker network connect networkName 【容器名】 # 访问地址：【容器名】:8080 ","permalink":"https://sanbeiicecream.github.io/posts/docker%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","summary":"https://docs.docker.com/network/ 1 2 # 查看docker网络 docker network ls 在创建容器时，使用-P -p 可以端口映射与宿主机进行通信；如果多个容器使用同一个主机端口创建容器会报错 容器之间","title":"Docker容器之间网络通信"},{"content":"在使用minio-js sdk上传文件时，出现\n==S3Error: The request signature we calculated does not match the signature you provided. Check your key and signing method.==\n是不是服务器时区不对导致的？通过设置时间同步\n1 2 3 4 5 6 7 8 9 10 11 # 时区设置 sudo timedatectl set-timezone Asia/Shanghai # 安装NTP（Network Time Protocol）服务，它用于同步系统时间 sudo yum install ntp # 启动 systemctl start ntp systemctl enable ntp date 发现还是会出现这个问题\n经过不断尝试发现查看桶数据的API是可以的打印出信息的，那么问题可能出现在上传接口，由于后台是用nginx转发的，通过查看nginx日志发现上传的时候出现了一个HEAD请求\n当请求路径出现两个杠==//==时会使用HEAD请求头返回403就会提示上面哪个报错\n发现是在使用原来是使用putObject api时，传入的对象名称在前面多加了一个==/==去掉即可\n然后又报了：==S3Error: Access Denied.==\n发现是请求链接上添加了请求参数location，找不到就报错了\n需要给账号设置桶权限\u0026quot;s3: GetBucketLocation\u0026quot;\n","permalink":"https://sanbeiicecream.github.io/posts/s3error-the-request-signature-we-calculated-does-not-match-the-signature-you-provided.-check-your-key-and-signing-method/","summary":"在使用minio-js sdk上传文件时，出现 ==S3Error: The request signature we calculated does not match the signature you provided. Check your key and signing method.== 是不是服务器时区不对导致的？通过设置时间同步 1 2 3 4 5 6 7","title":"S3Error - The request signature we calculated does not match the signature you provided. Check your key and signing method"},{"content":"最近有个库需要使用node18+版本，所以在node上安装了nvm\nhttps://github.com/nvm-sh/nvm\n1 2 3 4 5 6 7 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash command -v nvm nvm ls-remote nvm install 【版本】 npm -v时提示有几个库的版本没有找到\n看提示是需要安装glibc-2.28版本才能使用\n1 2 3 4 5 6 7 8 # 下载包 wget http://ftp.gnu.org/gnu/glibc/glibc-2.28.tar.gz # 解压 tar xf glibc-2.28.tar.gz # 进入源码里面 创建build 文件夹 并执行配置命令 cd glibc-2.28/ \u0026amp;\u0026amp; mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin 有可能会提示工具太旧了，先升级工具\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 升级GCC(默认为4 升级为8) yum install -y centos-release-scl yum install -y devtoolset-8-gcc* mv /usr/bin/gcc /usr/bin/gcc-4.8.5 ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gcc mv /usr/bin/g++ /usr/bin/g++-4.8.5 ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++ # 升级 make(默认为3 升级为4) wget http://ftp.gnu.org/gnu/make/make-4.3.tar.gz tar -xzvf make-4.3.tar.gz \u0026amp;\u0026amp; cd make-4.3/ ./configure --prefix=/usr/local/make make \u0026amp;\u0026amp; make install cd /usr/bin/ \u0026amp;\u0026amp; mv make make.bak ln -sv /usr/local/make/bin/make /usr/bin/make 升级完成后可能还会提示这个错，查看bison版本\n没有找到，先安装\n1 yum install -y bison 继续配置编译选项\n1 2 cd /root/glibc-2.28/build ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin 编译安装\n1 make \u0026amp;\u0026amp; make install 开始疯狂编译\n可能会报错\n打印包\n1 strings /lib64/libc.so.6 | grep GLIBC 发现安装上了 现在只有三个报错了\n在git上找到一个解决方法 ，需要安装Anaconda，里面的库是正确的\n1 2 3 4 5 6 7 8 9 # 需要完全安装，有个引导安装的提示 wget https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh sh Anaconda3-2019.07-Linux-x86_64.sh # 完成安装后，安装文件会在root目录下 cp anaconda3/lib/libstdc++.so.6.0.26 /usr/lib64 rm /usr/lib64/libstdc++.so.6 ln -s /usr/lib64/libstdc++.so.6.0.26 /usr/lib64/libstdc++.so.6 成功运行！\n","permalink":"https://sanbeiicecream.github.io/posts/centos7-%E5%AE%89%E8%A3%85node18+-%E8%A7%A3%E5%86%B3%E6%8A%A5%E9%94%99/","summary":"最近有个库需要使用node18+版本，所以在node上安装了nvm https://github.com/nvm-sh/nvm 1 2 3 4 5 6 7 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash command -v nvm nvm ls-remote nvm install 【版本】 npm -v时提示有几个库的版本","title":"centos7 安装node18+ 解决报错"},{"content":"公司内网的Jenkins需要使用EasyConnection才能访问，但是这软件有点流氓\n在自己电脑上是未开源的代理软件一概不敢使用怕有后门，所以在git上找到一个可以使用docker容器运行这软件的库\nhttps://github.com/Hagb/docker-easyconnect\n由于我的windows系统，现在可以在wsl2环境上进行试验，但是为了方便我在VMWare的centos系统上进行了操作\n果然过于复杂的东西都不是能够一下就成功的\ndocker安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 yum remove docker docker-common docker-selinux docker-engine # 安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖 yum install -y yum-utils device-mapper-persistent-data lvm2 # 设置一个yum源，下面两个都可用 yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo（中央仓库） yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库） # 选择docker版本并安装 （1）查看可用版本有哪些 yum list docker-ce --showduplicates | sort -r #（2）选择一个版本并安装：yum install docker-ce-版本号 yum -y install docker-ce-20.10.9 systemctl start docker systemctl enable docker 启动容器 作者提供了两个版本镜像，一个是纯cli的，一个提供了vnc界面\n由于是使用centos所以直接使用cli版本的\n1 docker run --device /dev/net/tun --cap-add NET_ADMIN -ti -p 127.0.0.1:1080:1080 -p 127.0.0.1:8888:8888 -e EC_VER=7.6.3 -e CLI_OPTS=\u0026#34;-d vpnaddress -u username -p password\u0026#34; --name ec hagb/docker-easyconnect:cli vpnaddress -\u0026gt; 代理的地址 username -\u0026gt; 密码 password -\u0026gt; 账号 运行后可以看到打印\n然后在本地ping虚拟机上的端口，居然不通 虚拟机上1080 与 8888这两个端口，防火墙也是放行的\n经过一段时间的尝试，弄不出来，于是在Issue里面寻找答案，经过一番寻找，原来是命令里面的端口映射的方式有问题\nhttps://github.com/Hagb/docker-easyconnect/issues/103#issuecomment-1016429807\n把127.0.0.1去掉就可以了\n为什么加上ip就不行了呢 首先是命令的差异性\ndocker run -p ip:hostPort:containerPort\nhostPort:containerPort（映射所有接口地址）\nip:hostPort:containerPort （映射指定地址的指定端口）\n加上127.0.0.1是映射127.0.0.1:port到docker的port上，而由于是使用的虚拟机，还需要先连上虚拟机的ipv4地址，所以是127.0.0.1 != 虚拟机ip导致的\n如果非想加上ip的话，有两个办法可以实现\n在虚拟机里面使用有转发功能的软件指定一个端口转发到127.0.0.1:8888上（nginx，caddy） 直接使用ipv4地址 然后在浏览器里面使用Proxy SwitchyOmega扩展添加一下虚拟机的centos机器的8888/http代理或者1080/socket5代理\n直接访问需要通过easyconnetion连接的路径\n成功进入！\n","permalink":"https://sanbeiicecream.github.io/posts/%E4%BD%BF%E7%94%A8vmware%E5%AE%89%E8%A3%85docker%E8%BF%90%E8%A1%8Ceasyconnection/","summary":"公司内网的Jenkins需要使用EasyConnection才能访问，但是这软件有点流氓 在自己电脑上是未开源的代理软件一概不敢使用怕有后门，","title":"VMware使用docker安装EasyConnection"},{"content":"最近在使用axios时发现当出现400时控制台会打印 于是决定去看看axios源码中会把哪些响应状态码reject出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 lib ├─axios.js ├─utils.js ├─platform | ├─index.js | ├─node | | ├─index.js | | ├─classes | | | ├─FormData.js | | | └URLSearchParams.js | ├─browser | | ├─index.js | | ├─classes | | | ├─Blob.js | | | ├─FormData.js | | | └URLSearchParams.js ├─helpers | ├─AxiosTransformStream.js | ├─AxiosURLSearchParams.js | ├─bind.js | ├─buildURL.js | ├─combineURLs.js | ├─cookies.js | ├─deprecatedMethod.js | ├─formDataToJSON.js | ├─formDataToStream.js | ├─fromDataURI.js | ├─HttpStatusCode.js | ├─isAbsoluteURL.js | ├─isAxiosError.js | ├─isURLSameOrigin.js | ├─null.js | ├─parseHeaders.js | ├─parseProtocol.js | ├─readBlob.js | ├─README.md | ├─speedometer.js | ├─spread.js | ├─throttle.js | ├─toFormData.js | ├─toURLEncodedForm.js | ├─validator.js | └ZlibHeaderTransformStream.js ├─env | ├─data.js | ├─README.md | ├─classes | | └FormData.js ├─defaults | ├─index.js | └transitional.js ├─core | ├─Axios.js | ├─AxiosError.js | ├─AxiosHeaders.js | ├─buildFullPath.js | ├─dispatchRequest.js | ├─InterceptorManager.js | ├─mergeConfig.js | ├─README.md | ├─settle.js | └transformData.js ├─cancel | ├─CanceledError.js | ├─CancelToken.js | └isCancel.js ├─adapters | ├─adapters.js | ├─http.js | ├─README.md | └xhr.js xhr.js\n可以看出在xhr.js中会收集XMLHttpRequest对象的abort、onerror、timeout事件进行reject一个AxiosError对象。\n在Axios的config中找到一个配置可以更改rejected的时机的属性\nhttps://axios-http.com/docs/req_config 因为xhr.js在adapters文件下面，由此可知该js是个适配器\n什么是适配器 在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装（英语：wrapper）。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。\n在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。\n对象适配器模式 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。 类适配器模式 这种适配器模式下，适配器继承自己实现的类（一般多重继承）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const obj1 = { run: function(){ console.log(\u0026#39;跑\u0026#39;) } } const obj2 = { walk: function(){ console.log(\u0026#39;走\u0026#39;) } } const start = function(obj){ if(obj.run instanceof Function){ obj.run() } } // 为了兼容obj2的walk方法，需要一个适配器来兼容 const obj2Adapter = { ...obj2, run: function(){ return this.walk(); } } start(obj1) start(obj2Adapter) 如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种“亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式把旧接口包装成一个新的接口，使它继续保持生命力。\n","permalink":"https://sanbeiicecream.github.io/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"最近在使用axios时发现当出现400时控制台会打印 于是决定去看看axios源码中会把哪些响应状态码reject出来 1 2 3 4 5 6 7 8 9 10 11 12","title":"适配器模式"},{"content":"结论：使用其他工具集成gitbash如果不加载配置会出现中文乱码问题\n先在git bash中将字符编码改成UTF-8\n然后在其他集成git bash的软件中添加**-i -l** 参数加载git bash的配置文件\nwin11 终端 在终端的JSON配置中修改一下属性值\n1 2 3 4 5 { ... \u0026#34;commandline\u0026#34;: \u0026#34;%PROGRAMFILES%\\\\bin\\\\bash.exe -i -l\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;%PROGRAMFILES%\\\\mingw64\\\\share\\\\git\\\\git-for-windows.ico\u0026#34;, } %PROGRAMFILES% 代表git bash安装目录\nvscode 1 2 3 4 5 6 7 8 9 { \u0026#34;terminal.integrated.profiles.windows\u0026#34;: { \u0026#34;gitBash\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;%PROGRAMFILES%\\\\bin\\\\bash.exe\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;-i\u0026#34;, \u0026#34;-l\u0026#34;] } }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;gitBash\u0026#34;, } 打开外部终端 这时就没有参数可以像上面那样直接设置了，但是可以直接打开win11的终端，让win11的终端默认开启一个git bash，从而间接创建一个git bash。\n1 2 3 4 { \u0026#34;terminal.explorerKind\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;terminal.external.windowsExec\u0026#34;: \u0026#34;%LocalAppData%\\\\Microsoft\\\\WindowsApps\\\\wt.exe\u0026#34;, } 缺点 第一个终端打开后，后续终端打开的路径默认是第一个打开的路径，原因是目前vscode无法指定打开外部终端的参数\n更新 2023-07-14 22-56\n使用gitbash打开终端 vscode 配置\n1 2 3 4 5 { \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;gitBash\u0026#34;, \u0026#34;terminal.explorerKind\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;terminal.external.windowsExec\u0026#34;: \u0026lt;git-bash路径\u0026gt;, } 使用快捷键可以打开gitbash，然后执行wt命令就可以直接打开终端了，这下每个vscode都能打开独立的终端不会存在路径不对的问题\n","permalink":"https://sanbeiicecream.github.io/posts/%E8%A7%A3%E5%86%B3gitbash%E4%B8%8E%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E9%9B%86%E6%88%90%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","summary":"结论：使用其他工具集成gitbash如果不加载配置会出现中文乱码问题 先在git bash中将字符编码改成UTF-8 然后在其他集成git bash","title":"解决gitbash与其他软件集成中文乱码问题"},{"content":" 1 2 “要理解递归，首先要理解递归。” ——佚名 递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。\n概念就这么简单，那么直接上手实战试试。\n阶乘 数 n 的阶乘，定义为 n!，表示从1到n的整数的乘积。 5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120。\n1 2 3 4 5 6 7 8 9 function factorialIterative(number) { if (number \u0026lt; 0) return undefined; let total = 1; for (let n = number; n \u0026gt; 1; n--) { total = total * n; } return total; } console.log(factorialIterative(5)); 斐波那契数列 斐波那契数列是另一个可以用递归解决的问题。它是一个由 0、1、1、2、3、5、8、13、21、34 等数组成的序列。数 2 由 1 + 1 得到，数 3 由 1 + 2 得到，数 5 由 2 + 3 得到，以此类推。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function fibonacciIterative(n) { if (n \u0026lt; 1) return 0; if (n \u0026lt;= 2) return 1; let fibNMinus2 = 0; let fibNMinus1 = 1; let fibN = n; for (let i = 2; i \u0026lt;= n; i++) { // n \u0026gt;= 2 fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2) fibNMinus2 = fibNMinus1; fibNMinus1 = fibN; } return fibN; } 会了吗？不，还完全不会 函数自己调自己只是递归的一个特征而已，这一步只要是学会了基本语法都能写出来，但是在递归中有很多细节是没有能够注意到。\n什么情况下用递归 开始递归的位置在哪里 结束的条件的什么 递-\u0026gt;归之间的值应该传递什么 递\u0026lt;-归之间的值应该传递什么 \u0026hellip; 不信可以看个难一点的问题\n汉诺塔（Tower of Hanoi） 1 2 3 4 5 6 是根据一个传说形成的数学问题： 有三根杆子A，B，C。A杆上有 N 个 (N\u0026gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆： 1. 每次只能移动一个圆盘； 2. 大盘不能叠在小盘上面。 根据上面两个例子的经验，在这个问题就毫无思路了\n1 // ??? 每日一个排序算法写到了归并排序后就没写快速排序的原因就是因为快排需要深刻得递归理解才能理解其精华。\n快速排序 计数排序 桶排序 基数排序 ","permalink":"https://sanbeiicecream.github.io/posts/%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/","summary":"1 2 “要理解递归，首先要理解递归。” ——佚名 递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调","title":"理解递归"},{"content":"归并排序是第一个可以实际使用的排序算法。（冒泡、插入、选择）三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\nJavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n由于是分治法，归并排序也是递归的。我们要将算法分为两个函数：\n第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。 第二个负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。 分而治之 分而治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，\n再将解决方式合并以解决原来的问题。\n分而治之算法可以分成三个部分。\n分解原问题为多个子问题（原问题的多个小实例）。 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。 组合这些子问题的解决方式，得到原问题的解。 可以看出这个方法将会花很多时间在最初的思考上，是个非常抽象的方法，在递归时一定需要一个终止条件，不然递归栈会溢出。\n思路\n分解问题\n一个长度为n的数组，最简单就是分成两个数组，每个数组只有一项比较，那么可以将一个长数组拆分成log2n个数组比较\n解决子问题\n在两个数组比较时，分为左数组和右数组，比较完后一定要保证小的数在前面，大的数在后面，利用空间换时间可以只需比较此次数组的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 递归主体 function mergeSort(array){ let result = array if(array.length \u0026gt; 1){\t//递归终止条件 const {length}\t= array\t//解构赋值 const middle = Math.floor(length / 2) const left = mergeSort(array.slice(0, middle))\t// 递归得出左数组 const right = mergeSort(array.slice(middle))\t// 递归得出右数组 result = merge(left, right)\t// 在每次递归后，排好序 } return result } // 将两个有序数组排序成一个有序数组 // 因为是从一个值的时候开始排的，所以每次递归过程中的值都是有序的 function merge(left, right){ let i = 0 let j = 0 const result = [] // 逻辑与，每次循环必然会有一个数组可以遍历完 while(i \u0026lt; left.length \u0026amp;\u0026amp; j \u0026lt; right.length){ result.push(left[i] \u0026lt; right[j]? left[i++] : right[j++] ) } // 经过上面循环后需要将没有压入result中的数组连接上 return result.concat(i \u0026lt; left.length ? left.slice(i) : right.slice(j)) } let array = [5, 6, 1, 1, 2, 7, 3] mergeSort(array) 递归方法很抽象，需要仔细思考才能得出一个正确的解，但是一旦得到解了，代码量就很少。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","summary":"归并排序是第一个可以实际使用的排序算法。（冒泡、插入、选择）三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。 JavaScript 的 Array","title":"每天一个排序算法 ---归并排序"},{"content":"插入排序每次排一个数组项，以此方式构建最后的排序数组。 每次排的数组项依次增加1，第一次需要排序的数组项为1，第二次为2，直到需要排序数组的长度。\n思路\n数组长度为n\n需要比j较n轮\n每轮需要比较：直到当前比较的数大于前面排好的数组的某个数组项为止\n每次比较满足条件就交换位置\n1 2 3 4 5 6 7 8 9 10 let array = [2, 5, 1, 4, 3] for(let i = 0; i \u0026lt; array.length; i++){ let j = i let tem = array[i] while(j \u0026gt; 0 \u0026amp;\u0026amp; tem \u0026lt; array[j - 1]){ [array[j],array[j-1]] = [array[j-1],array[j]]\t// 解构赋值 j-- } } console.log(array) 注意观察j和i的赋值情况，为什么不用下面这种写法\n1 2 3 4 5 6 7 8 9 10 const array = [5,4,3, 2, 1] for(let i = 0; i \u0026lt; array.length; i++){ let j = i let tem = array[j + 1] while (j \u0026gt;= 0 \u0026amp;\u0026amp; tem \u0026lt; array[j]){ [array[j], array[j + 1]] = [array[j + 1], array[j]]; j-- } } console.log(array) 因为这个写法不好，需要额外比较一次（索引为0时）和当索引为最大时array[j+1]会数组溢出\n插入排序算法的关键点在于，从少到多这个过程，每次都是排好序的。\n使用while循环不使用for循环是更符合语义的。\n排序小型数组时，此算法比选择排序和冒泡排序性能要好，因为插入排序的每轮的比较都是在已经排好序的数组中比较插入可以减少比较的次数，而冒泡和选择都是需要比较全部剩余数组项。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"插入排序每次排一个数组项，以此方式构建最后的排序数组。 每次排的数组项依次增加1，第一次需要排序的数组项为1，第二次为2，直到需要排序数组的长","title":"每天一个排序算法 ---插入排序"},{"content":"选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。\n与冒泡排序一样都需要两个for循环遍历，不同点是交换的思路不同\n冒泡排序是在循环遍历中，比较相邻两数大小并交换位置 选择排序是在循环遍历中记录本轮循环当前最小值的索引，当本轮循环完后交换遍历开始索引与最小值索引的值 思路： 有n个数，需要n轮遍历\n每次遍历，较上轮需要比较的次数 - 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const array = [5, 4, 3, 2, 1] let minIndex for(i = 0;i \u0026lt; array.length; i++){ minIndex = i\t// 每轮开始默认最小值索引 for(j = i; j \u0026lt; array.length; j++){ if(array[minIndex] \u0026gt; array[j]){ minIndex = j } } // 如果遍历完一轮，minIndex改变了，就交换值,i是本轮默认最小值的索引 if(minIndex !== i){ [array[minIndex],array[i]] = [array[i],arr[minIndex]] } } console.log(array) 与冒泡排序两次for循环比较，j的初始值参数是等于i的，为什么不能从0开始\n冒泡排是每轮是将大数的放在最后，每轮比较的索引不会用到后面的值，所以可以从0开始 选择排序是每轮将最小的放在前面，每轮比较的所以要用到最后，所以必须从i开始 选择排序同样也是一个复杂度为 O(n2)的算法，和冒泡排序一样。 ","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类","title":"每天一个排序算法 ---选择排序"},{"content":"冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。\n元素项向后移动至正确的顺序\n就好像气泡升至表面一样，从一个小气泡慢慢变大，交换的过程就可以类比成变大的过程，所以叫冒泡排序。\n简化：\n有n个数\n需要比较n轮\n每轮需要比较n - 1次\n1 2 3 4 5 6 7 8 9 let array = [5,4,3,2,1] for(let i = 0; i \u0026lt; array.length; i++){ for(let j = 0; j \u0026lt; array.length - 1; j++){ if(array[j] \u0026gt; array [j+1]){ [array[j],array[j+1]] = [array[j+1],array[j]]\t//解构赋值 } } } console.log(array) 优化： 每轮比较后，最大的数占了一个位置，所以下一轮比较的次数可以比上一轮少一次\n1 2 3 4 5 6 7 8 9 let array = [5,4,3,2,1] for(let i = 0; i \u0026lt; array.length; i++){ for(let j = 0; j \u0026lt; array.length - i - 1; j++){ if(array[j] \u0026gt; array [j+1]){ [array[j],array[j+1]] = [array[j+1],array[j]]\t//解构赋值 } } } console.log(array) 冒泡排序与其他排序算法相比，是最符合大脑直观感受的，也是最简单的，但是与其他排序算法比较，也是时间复杂度（O^2）最高的。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。 元素项向后移动至正确的顺序 就好像气泡升至表面一样，从一个小气泡慢慢变大，交换","title":"每天一个排序算法 ---冒泡排序"},{"content":"使用obsidian进行博客文章编辑时，需要下载一个生成模板的工具，不然使用hugo new xxx生成模板有点麻烦，需要下载一个插件 官方配置\n1 2 3 4 5 6 --- title: \u0026#34;\u0026lt;% tp.file.title %\u0026gt;\u0026#34; date: \u0026#34;\u0026lt;% tp.date.now() %\u0026gt;\u0026#34; draft: false tags: --- 然后使用obsidian创建一个新文件，插入模板 有是有了但是不够友好，时间应该生成ISO8601的格式 修改插件代码 找到插件位置，发现这插件是用JS写的 找到main.js中关键代码片段 加这几行代码，完成！！！easy 在模板中date: \u0026quot;\u0026lt;% tp.date.now('iso') %\u0026gt;\u0026quot; 重启obsidian，试一试是ok的 ","permalink":"https://sanbeiicecream.github.io/posts/%E4%BD%BF%E7%94%A8obsidian%E7%9A%84templater%E6%8F%92%E4%BB%B6%E6%9B%BF%E4%BB%A3hugo-new%E5%91%BD%E4%BB%A4/","summary":"使用obsidian进行博客文章编辑时，需要下载一个生成模板的工具，不然使用hugo new xxx生成模板有点麻烦，需要下载一个插件 官方配置 1 2 3","title":"使用obsidian的Templater插件替代hugo new命令"},{"content":" 修改文件都是用的同级覆盖方式，没有修改themes里面的文件 上面图片占用的面积太大了，需要调整一下放在右侧 修改文件layouts =\u0026gt; _default =\u0026gt; list.html 定位到关键代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 修改页面dom结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;article class=\u0026#34;{{ $class }} list-container\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;/div\u0026gt; \u0026lt;/article\u0026gt; 在blank.css中添加\n1 2 3 4 5 6 7 8 9 .list-container{ display: flex; align-items: center; } .list-container \u0026gt; div:nth-child(1){ min-width: 60%; } 完成！ ","permalink":"https://sanbeiicecream.github.io/posts/%E5%B0%86papermod%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%B3%E4%BE%A7/","summary":"修改文件都是用的同级覆盖方式，没有修改themes里面的文件 上面图片占用的面积太大了，需要调整一下放在右侧 修改文件layouts =\u0026gt; _default =\u0026gt; list.html 定位","title":"将PaperMod主题图片移动到右侧"},{"content":"谷歌浏览器这是要干嘛？？？ 果断设置里面=\u0026gt; 隐私设置和安全性 =\u0026gt; 安全浏览 里面关闭 ","permalink":"https://sanbeiicecream.github.io/posts/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%A0%E8%A6%81%E5%B9%B2%E4%BB%80%E4%B9%88/","summary":"谷歌浏览器这是要干嘛？？？ 果断设置里面=\u0026gt; 隐私设置和安全性 =\u0026gt; 安全浏览 里面关闭","title":"谷歌浏览器你要干什么"},{"content":"先动起来 配置优先的一个静态页面生成的框架 先安装hugo后，需要先安装golang\n1 2 3 # 先创建一个模板 hugo new site xxx # 然后下载一个主题放在themes文件夹里面，在config.yml中theme指定主题（文件夹名） 下载主题最好是使用git submodule命令进行仓库链接，这样后续可以对主题的修改进行单独维护\n1 2 3 4 5 6 # 先进入模板文件夹 cd xxx # 初始化git git init # 关联主题子项目 git submodule add https://github.com/adityatelange/hugo-PaperMod/ themes/PaperMod Why? fork的原因在于当原始的仓库进行变更后，可以选择性进行合并，以便即使现在版本落后很多也不会合并和样式出现大范围问题。 进行自定义时，不能修改themes里面的主题，因为是通过git submodule add的，修改后，推代码并不会推送到github上，要么修改自己fork的主题库，最好是通过在外面通过和theme一样的层级文件进行覆盖\n修改配置 配置文件在当前模板的根下，但是hugo默认创建的是toml格式的配置文件，这个格式的个人感觉没有yml格式的好用，从PaperMod的exampleSite分支拷贝yml配置过来hugo-PaperMod/config.yml at exampleSite · adityatelange/hugo-PaperMod (github.com) 修改\n1 2 # 这个值为themes文件夹主题的名称，用哪个就写哪个 theme: PaperMod 然后运行看效果\n1 2 # 启动查看效果 hugo server 动起来了！！！\n初级改造 先改造得顺眼，后面再加各种功能 有些配置修改后需要重启服务才会生效，比如i18n里面的配置 根据页面类名定位到这里是在partial目录下的post_meta.html中定义的模板 这三个标签需要在content里面添加archive.md search.md才能显示出来\n1 2 3 4 5 6 7 8 --- title: \u0026#34;🔍搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;输入关键字 + Enter\u0026#34; --- 1 2 3 4 5 6 --- title: \u0026#34;⏱时间轴\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- 配置详解 为什么把这个放最后，因为这配置项有很多，本来主题都是用的现成的，要定制一下只需要几个关键的属性就够了，这配置都当个速查手册了。\n","permalink":"https://sanbeiicecream.github.io/posts/hugo%E4%BD%BF%E7%94%A8papermod%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","summary":"先动起来 配置优先的一个静态页面生成的框架 先安装hugo后，需要先安装golang 1 2 3 # 先创建一个模板 hugo new site xxx # 然后下载一个主题放在them","title":"hugo使用PaperMod主题搭建静态博客"},{"content":"图床test ","permalink":"https://sanbeiicecream.github.io/posts/%E5%9B%BE%E5%BA%8A-hosting-test/","summary":"图床test","title":"图床 Test"},{"content":"还是开始那样的 Hello World！\n","permalink":"https://sanbeiicecream.github.io/posts/blog-test/","summary":"还是开始那样的 Hello World！","title":"Blog Test"},{"content":"","permalink":"https://sanbeiicecream.github.io/assets/image_1676469514615_0.png/","summary":"","title":""},{"content":"","permalink":"https://sanbeiicecream.github.io/about/","summary":"archives","title":"妙呀"}]