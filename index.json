[{"content":"归并排序是第一个可以实际使用的排序算法。（冒泡、插入、选择）三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\nJavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n由于是分治法，归并排序也是递归的。我们要将算法分为两个函数：\n第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。 第二个负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。 分而治之 分而治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，\n再将解决方式合并以解决原来的问题。\n分而治之算法可以分成三个部分。\n分解原问题为多个子问题（原问题的多个小实例）。 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。 组合这些子问题的解决方式，得到原问题的解。 可以看出这个方法将会花很多时间在最初的思考上，是个非常抽象的方法，在递归时一定需要一个终止条件，不然递归栈会溢出。\n思路\n分解问题\n一个长度为n的数组，最简单就是分成两个数组，每个数组只有一项比较，那么可以将一个长数组拆分成log2n个数组比较\n解决子问题\n在两个数组比较时，分为左数组和右数组，比较完后一定要保证小的数在前面，大的数在后面，利用空间换时间可以只需比较此次数组的长度\n// 递归主体 function mergeSort(array){ let result = array if(array.length \u0026gt; 1){\t//递归终止条件 const {length}\t= array\t//解构赋值 const middle = Math.floor(length / 2) const left = mergeSort(array.slice(0, middle))\t// 递归得出左数组 const right = mergeSort(array.slice(middle))\t// 递归得出右数组 result = merge(left, right)\t// 在每次递归后，排好序 } return result } // 将两个有序数组排序成一个有序数组 // 因为是从一个值的时候开始排的，所以每次递归过程中的值都是有序的 function merge(left, right){ let i = 0 let j = 0 const result = [] // 逻辑与，每次循环必然会有一个数组可以遍历完 while(i \u0026lt; left.length \u0026amp;\u0026amp; j \u0026lt; right.length){ result.push(left[i] \u0026lt; right[j]? left[i++] : right[j++] ) } // 经过上面循环后需要将没有压入result中的数组连接上 return result.concat(i \u0026lt; left.length ? left.slice(i) : right.slice(j)) } let array = [5, 6, 1, 1, 2, 7, 3] mergeSort(array) 递归方法很抽象，需要仔细思考才能得出一个正确的解，但是一旦得到解了，代码量就很少。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","summary":"归并排序是第一个可以实际使用的排序算法。（冒泡、插入、选择）三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。 JavaScript 的 Array","title":"每天一个排序算法 ---归并排序"},{"content":"插入排序每次排一个数组项，以此方式构建最后的排序数组。 每次排的数组项依次增加1，第一次需要排序的数组项为1，第二次为2，直到需要排序数组的长度。\n思路\n数组长度为n\n需要比j较n轮\n每轮需要比较：直到当前比较的数大于前面排好的数组的某个数组项为止\n每次比较满足条件就交换位置\nlet array = [2, 5, 1, 4, 3] for(let i = 0; i \u0026lt; array.length; i++){ let j = i let tem = array[i] while(j \u0026gt; 0 \u0026amp;\u0026amp; tem \u0026lt; array[j - 1]){ [array[j],array[j-1]] = [array[j-1],array[j]]\t// 解构赋值 j-- } } console.log(array) 注意观察j和i的赋值情况，为什么不用下面这种写法\nconst array = [5,4,3, 2, 1] for(let i = 0; i \u0026lt; array.length; i++){ let j = i let tem = array[j + 1] while (j \u0026gt;= 0 \u0026amp;\u0026amp; tem \u0026lt; array[j]){ [array[j], array[j + 1]] = [array[j + 1], array[j]]; j-- } } console.log(array) 因为这个写法不好，需要额外比较一次（索引为0时）和当索引为最大时array[j+1]会数组溢出\n插入排序算法的关键点在于，从少到多这个过程，每次都是排好序的。\n使用while循环不使用for循环是更符合语义的。\n排序小型数组时，此算法比选择排序和冒泡排序性能要好，因为插入排序的每轮的比较都是在已经排好序的数组中比较插入可以减少比较的次数，而冒泡和选择都是需要比较全部剩余数组项。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"插入排序每次排一个数组项，以此方式构建最后的排序数组。 每次排的数组项依次增加1，第一次需要排序的数组项为1，第二次为2，直到需要排序数组的长","title":"每天一个排序算法 ---插入排序"},{"content":"选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。\n与冒泡排序一样都需要两个for循环遍历，不同点是交换的思路不同\n冒泡排序是在循环遍历中，比较相邻两数大小并交换位置 选择排序是在循环遍历中记录本轮循环当前最小值的索引，当本轮循环完后交换遍历开始索引与最小值索引的值 思路： 有n个数，需要n轮遍历\n每次遍历，较上轮需要比较的次数 - 1\nconst array = [5, 4, 3, 2, 1] let minIndex for(i = 0;i \u0026lt; array.length; i++){ minIndex = i\t// 每轮开始默认最小值索引 for(j = i; j \u0026lt; array.length; j++){ if(array[minIndex] \u0026gt; array[j]){ minIndex = j } } // 如果遍历完一轮，minIndex改变了，就交换值,i是本轮默认最小值的索引 if(minIndex !== i){ [array[minIndex],array[i]] = [array[i],arr[minIndex]] } } console.log(array) 与冒泡排序两次for循环比较，j的初始值参数是等于i的，为什么不能从0开始\n冒泡排是每轮是将大数的放在最后，每轮比较的索引不会用到后面的值，所以可以从0开始 选择排序是每轮将最小的放在前面，每轮比较的所以要用到最后，所以必须从i开始 选择排序同样也是一个复杂度为 O(n2)的算法，和冒泡排序一样。 ","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类","title":"每天一个排序算法 ---选择排序"},{"content":"冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。\n元素项向后移动至正确的顺序\n就好像气泡升至表面一样，从一个小气泡慢慢变大，交换的过程就可以类比成变大的过程，所以叫冒泡排序。\n简化：\n有n个数\n需要比较n轮\n每轮需要比较n - 1次\nlet array = [5,4,3,2,1] for(let i = 0; i \u0026lt; array.length; i++){ for(let j = 0; j \u0026lt; array.length - 1; j++){ if(array[j] \u0026gt; array [j+1]){ [array[j],array[j+1]] = [array[j+1],array[j]]\t//解构赋值 } } } console.log(array) 优化： 每轮比较后，最大的数占了一个位置，所以下一轮比较的次数可以比上一轮少一次\nlet array = [5,4,3,2,1] for(let i = 0; i \u0026lt; array.length; i++){ for(let j = 0; j \u0026lt; array.length - i - 1; j++){ if(array[j] \u0026gt; array [j+1]){ [array[j],array[j+1]] = [array[j+1],array[j]]\t//解构赋值 } } } console.log(array) 冒泡排序与其他排序算法相比，是最符合大脑直观感受的，也是最简单的，但是与其他排序算法比较，也是时间复杂度（O^2）最高的。\n","permalink":"https://sanbeiicecream.github.io/posts/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95---%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。 元素项向后移动至正确的顺序 就好像气泡升至表面一样，从一个小气泡慢慢变大，交换","title":"每天一个排序算法 ---冒泡排序"},{"content":"使用obsidian进行博客文章编辑时，需要下载一个生成模板的工具，不然使用hugo new xxx生成模板有点麻烦，需要下载一个插件 官方配置\n--- title: \u0026#34;\u0026lt;% tp.file.title %\u0026gt;\u0026#34; date: \u0026#34;\u0026lt;% tp.date.now() %\u0026gt;\u0026#34; draft: false tags: --- 然后使用obsidian创建一个新文件，插入模板 有是有了但是不够友好，时间应该生成ISO8601的格式 修改插件代码 找到插件位置，发现这插件是用JS写的 找到main.js中关键代码片段 加这几行代码，完成！！！easy 在模板中date: \u0026quot;\u0026lt;% tp.date.now('iso') %\u0026gt;\u0026quot; 重启obsidian，试一试是ok的 ","permalink":"https://sanbeiicecream.github.io/posts/%E4%BD%BF%E7%94%A8obsidian%E7%9A%84templater%E6%8F%92%E4%BB%B6%E6%9B%BF%E4%BB%A3hugo-new%E5%91%BD%E4%BB%A4/","summary":"使用obsidian进行博客文章编辑时，需要下载一个生成模板的工具，不然使用hugo new xxx生成模板有点麻烦，需要下载一个插件 官方配置 --- title: \u0026#34;\u0026lt;%","title":"使用obsidian的Templater插件替代hugo new命令"},{"content":" 修改文件都是用的同级覆盖方式，没有修改themes里面的文件 上面图片占用的面积太大了，需要调整一下放在右侧 修改文件layouts =\u0026gt; _default =\u0026gt; list.html 定位到关键代码\n\u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 修改页面dom结构\n\u0026lt;article class=\u0026#34;{{ $class }} list-container\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;/div\u0026gt; \u0026lt;/article\u0026gt; 在blank.css中添加\n.list-container{ display: flex; align-items: center; } .list-container \u0026gt; div:nth-child(1){ min-width: 60%; } 完成！ ","permalink":"https://sanbeiicecream.github.io/posts/%E5%B0%86papermod%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%B3%E4%BE%A7/","summary":"修改文件都是用的同级覆盖方式，没有修改themes里面的文件 上面图片占用的面积太大了，需要调整一下放在右侧 修改文件layouts =\u0026gt; _default =\u0026gt; list.html 定位","title":"将PaperMod主题图片移动到右侧"},{"content":"谷歌浏览器这是要干嘛？？？ 果断设置里面=\u0026gt; 隐私设置和安全性 =\u0026gt; 安全浏览 里面关闭 ","permalink":"https://sanbeiicecream.github.io/posts/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%A0%E8%A6%81%E5%B9%B2%E4%BB%80%E4%B9%88/","summary":"谷歌浏览器这是要干嘛？？？ 果断设置里面=\u0026gt; 隐私设置和安全性 =\u0026gt; 安全浏览 里面关闭","title":"谷歌浏览器你要干什么"},{"content":"先动起来 配置优先的一个静态页面生成的框架 先安装hugo后，需要先安装golang\n# 先创建一个模板 hugo new site xxx # 然后下载一个主题放在themes文件夹里面，在config.yml中theme指定主题（文件夹名） 下载主题最好是使用git submodule命令进行仓库链接，这样后续可以对主题的修改进行单独维护\n# 先进入模板文件夹 cd xxx # 初始化git git init # 关联主题子项目 git submodule add https://github.com/adityatelange/hugo-PaperMod/ themes/PaperMod Why? fork的原因在于当原始的仓库进行变更后，可以选择性进行合并，以便即使现在版本落后很多也不会合并和样式出现大范围问题。 进行自定义时，不能修改themes里面的主题，因为是通过git submodule add的，修改后，推代码并不会推送到github上，要么修改自己fork的主题库，最好是通过在外面通过和theme一样的层级文件进行覆盖\n修改配置 配置文件在当前模板的根下，但是hugo默认创建的是toml格式的配置文件，这个格式的个人感觉没有yml格式的好用，从PaperMod的exampleSite分支拷贝yml配置过来hugo-PaperMod/config.yml at exampleSite · adityatelange/hugo-PaperMod (github.com) 修改\n# 这个值为themes文件夹主题的名称，用哪个就写哪个 theme: PaperMod 然后运行看效果\n# 启动查看效果 hugo server 动起来了！！！\n初级改造 先改造得顺眼，后面再加各种功能 有些配置修改后需要重启服务才会生效，比如i18n里面的配置 根据页面类名定位到这里是在partial目录下的post_meta.html中定义的模板 这三个标签需要在content里面添加archive.md search.md才能显示出来\n--- title: \u0026#34;🔍搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;输入关键字 + Enter\u0026#34; --- --- title: \u0026#34;⏱时间轴\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- 配置详解 为什么把这个放最后，因为这配置项有很多，本来主题都是用的现成的，要定制一下只需要几个关键的属性就够了，这配置都当个速查手册了。\n","permalink":"https://sanbeiicecream.github.io/posts/hugo%E4%BD%BF%E7%94%A8papermod%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","summary":"先动起来 配置优先的一个静态页面生成的框架 先安装hugo后，需要先安装golang # 先创建一个模板 hugo new site xxx # 然后下载一个主题放在themes文","title":"hugo使用PaperMod搭建主题静搭建静态博客"},{"content":"图床test ","permalink":"https://sanbeiicecream.github.io/posts/%E5%9B%BE%E5%BA%8A-hosting-test/","summary":"图床test","title":"图床 Test"},{"content":"还是开始那样的 Hello World！\n","permalink":"https://sanbeiicecream.github.io/posts/blog-test/","summary":"还是开始那样的 Hello World！","title":"Blog Test"},{"content":"","permalink":"https://sanbeiicecream.github.io/assets/image_1676469514615_0.png/","summary":"","title":""}]